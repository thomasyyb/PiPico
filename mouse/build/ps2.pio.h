// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// --- //
// ps2 //
// --- //

#define ps2_wrap_target 0
#define ps2_wrap 7

static const uint16_t ps2_program_instructions[] = {
            //     .wrap_target
    0xe001, //  0: set    pins, 1                    
    0xe02b, //  1: set    x, 11                      
    0x2f0e, //  2: wait   0 gpio, 14             [15]
    0x4001, //  3: in     pins, 1                    
    0x208e, //  4: wait   1 gpio, 14                 
    0x2f0e, //  5: wait   0 gpio, 14             [15]
    0x0043, //  6: jmp    x--, 3                     
    0xef00, //  7: set    pins, 0                [15]
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program ps2_program = {
    .instructions = ps2_program_instructions,
    .length = 8,
    .origin = -1,
};

static inline pio_sm_config ps2_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + ps2_wrap_target, offset + ps2_wrap);
    return c;
}

#include "hardware/gpio.h"
static inline void ps2_program_init(PIO pio, uint sm, uint offset, float clkdiv, uint pin_clk, uint pin_data) {
    pio_sm_config c = ps2_program_get_default_config(offset);
    // sm_config_set_out_pins(&c, pin_clk, 1);
    // sm_config_set_set_pins(&c, pin_data, 1);
    sm_config_set_set_pins(&c, pin_clk, 1);
    sm_config_set_in_pins(&c, pin_data);
    // Only support MSB-first in this example code (shift to left, auto push/pull, threshold=nbits)
    // Turn off autopull
    // sm_config_set_out_shift(&c, false, false, n_bits);
    sm_config_set_in_shift(&c, false, false, 11);  // 11 bits per transaction
    sm_config_set_clkdiv(&c, clkdiv);
    // CLK and DATA are both input right now
    // pio_sm_set_pins_with_mask(pio, sm, 0, (1u << pin_sck) | (1u << pin_mosi));  // save this one as an set example
    // pio_sm_set_pins_with_mask(pio, sm, 1, (1u << pin_cs));  // save this one as an set example
    // set the pindirs as output for now
    pio_sm_set_pindirs_with_mask(pio, sm, (1u << pin_data) | (1u << pin_clk), (1u << pin_data) | (1u << pin_clk));
    pio_gpio_init(pio, pin_clk);
    pio_gpio_init(pio, pin_data);
    // The pin muxes can be configured to invert the output (among other things)
    // and this is a cheesy way to get CPOL=1
    // gpio_set_outover(pin_sck, cpol ? GPIO_OVERRIDE_INVERT : GPIO_OVERRIDE_NORMAL);
    // SPI is synchronous, so bypass input synchroniser to reduce input delay.
    // hw_set_bits(&pio->input_sync_bypass, 1u << pin_miso);  // maybe try this for PS/2 later
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

#endif

